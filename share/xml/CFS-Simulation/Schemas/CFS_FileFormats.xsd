<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
  targetNamespace="http://www.cfs++.org/simulation"
  xmlns="http://www.cfs++.org/simulation"
  xmlns:cfs="http://www.cfs++.org/simulation"
  elementFormDefault="qualified">

  <xsd:annotation>
    <xsd:documentation xml:lang="en">
      Coupled Field Solver project CFS++
      Schema description for various IO format and file definitions
    </xsd:documentation>
  </xsd:annotation>


  <!-- ******************************************************************** -->
  <!--   Definition file formats element data type -->
  <!-- ******************************************************************** -->

  <!-- Data type for defining the input, output and material formats -->
  <xsd:complexType name="DT_FileFormats">
    <xsd:sequence>
      <xsd:element name="input" type="DT_InputList" minOccurs="0" maxOccurs="1">
        <xsd:annotation>
          <xsd:documentation xml:lang="en">
            List of input files which contain meshes and data. 
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="scatteredData" type="DT_InputScatteredData" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="output" type="DT_OutputList" minOccurs="0" maxOccurs="1">
        <xsd:annotation>
          <xsd:documentation xml:lang="en">
            List of output files for mesh based data and history data. 
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="materialData" type="DT_MatFile" minOccurs="0" maxOccurs="1">
        <xsd:annotation>
          <xsd:documentation xml:lang="en">
            Specification of material data file. 
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>


  <!-- ******************************************************************** -->
  <!--   Definition of basic data input type -->
  <!-- ******************************************************************** -->

  <!-- This is an abstract basic input type so that it cannot appear in an -->
  <!-- instance document -->
  <xsd:complexType name="DT_InputBasic" abstract="true">
    <xsd:attribute name="id" type="xsd:token" default="default">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          Unique id  of this input tag. Can  be used later on  to specify from
          which input file certain data sets should be read.
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="gridId" type="xsd:token" default="default">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          CFS++  can   internally  handle  a   number  of  meshes   which  are
          distinguished by  this attribute. Per default all  meshes and inputs
          will be  read into  a mesh with  gridId="default". If more  than one
          mesh is required one can vary  the gridId, e.g. to get a second mesh
          from which data values may be interpolated to the first mesh.
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="fileName" type="xsd:token" default="default">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">Specify exact path to input file.
            </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>

  <!-- Definition of input element group -->
  <xsd:group name="InputGroup">
    <xsd:choice>
      <xsd:element name="gmsh" type="DT_InputGmsh"/>
      <xsd:element name="mesh" type="DT_InputMesh"/>
      <xsd:element name="mphtxt" type="DT_InputComsol"/>
      <xsd:element name="hdf5" type="DT_InputHDF5"/>
      <xsd:element name="cgns" type="DT_InputCGNS"/>
      <xsd:element name="unv" type="DT_InputUNV"/>
      <xsd:element name="cdb" type="DT_InputCDB"/>
      <xsd:element name="internal" type="DT_InputInternal"/>
      <xsd:element name="ensight" type="DT_InputEnsight"/>
      <xsd:element name="python" type="DT_InputPython"/>
    </xsd:choice>
  </xsd:group>

  <!--

  <xsd:group name="InputGroup">
    <xsd:sequence>
      <xsd:group ref="InputGroup" minOccurs="1" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:group>
-->

  <!-- Data type for specification of output file format -->
  <xsd:complexType name="DT_InputList">
    <xsd:sequence>
      <xsd:group ref="InputGroup" minOccurs="1" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of MESH data input type -->
  <!-- ******************************************************************** -->

  <!-- Data type for specification of input file format -->
  <xsd:complexType name="DT_InputMesh">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
        Original  mesh file  format of  CFS++. Can  be written  by  the mkmesh
        extension in ANSYS, the plugin in GiD or create_mesh.py. 
        Mesh  files are ASCII files  and were also supported by CAPA which is the predecessor of CFS++.
      </xsd:documentation>
    </xsd:annotation>

    <xsd:complexContent>
      <xsd:extension base="DT_InputBasic"> </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of GMSH  data input type -->
  <!-- ******************************************************************** -->

  <xsd:complexType name="DT_InputGmsh_RegionType">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
        The region names have either been assigned to the physical entities in
        Gmsh or CFS++ chooses them based  on the integer index of the physical
        entity. In the  former case CFS++ will use the names  from Gmsh and it
        is not  necessary to  redefine the  names.  In the  latter case  it is
        recommended to use  cfstool for converting the .msh in  order to get a
        list of the actual region names.
      </xsd:documentation>
    </xsd:annotation>

    <xsd:complexContent>
      <xsd:extension base="xsd:anyType">
        <xsd:attribute name="name" type="xsd:token" default="default">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
              This name will be assigned  by CFS++ to the given phsical entity
              from the .msh file.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="physicalEntity" type="xsd:nonNegativeInteger" default="0">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            Identify the physical entity for this region by an integer.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="linearize" type="xsd:boolean" default="false">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
              Read only linear versions (just corner nodes) of the elements in
              this region.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <!-- Data type for specification of input file format -->
  <xsd:complexType name="DT_InputGmsh">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
        Read mesh files generated using Gmsh (http://www.geuz.org/gmsh).
      </xsd:documentation>
    </xsd:annotation>

    <xsd:complexContent>
      <xsd:extension base="DT_InputBasic">
        <xsd:sequence minOccurs="0">
          <xsd:element name="region" type="DT_InputGmsh_RegionType" minOccurs="0"
            maxOccurs="unbounded"/>
        </xsd:sequence>
        <xsd:attribute name="coordSysId" type="xsd:token" default="default">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
              Use a coordinate system to transform all points in this mesh file.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="scaleFac" type="xsd:double" default="1.0">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
              Scale geometry using this factor.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of Comsol .mphtxt  data input type -->
  <!-- ******************************************************************** -->

  <xsd:complexType name="DT_InputComsol_RegionType">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
        Since no information about physical regions is saved in .mphtxt files, the regions have to be reassembled from surface and volume ids. The CFS++ regions are therefore assembled by specifying the domtype (volume or surface) and the list of ids in domains.
      </xsd:documentation>
    </xsd:annotation>

    <xsd:complexContent>
      <xsd:extension base="xsd:anyType">
        <xsd:attribute name="name" type="xsd:token" default="default">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
              This name will be assigned  by CFS++ to the given physical entity
              assembled from the domain ids in the .mphtxt file.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="domains" type="xsd:token" default="0">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
              Specify a list of domain numbers as generated by CFS++ for COMSOL meshes.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="domtype" type="xsd:token" default="volume">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
              May be 'surface' or 'volume' region.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>


  <!-- Data type for specification of input file format -->
  <xsd:complexType name="DT_InputComsol">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
        Read ASCII .mphtxt mesh files generated using Comsol (http://www.comsol.com).
      </xsd:documentation>
    </xsd:annotation>

    <xsd:complexContent>
      <xsd:extension base="DT_InputBasic">
        <xsd:sequence minOccurs="0">
          <xsd:element name="region" type="DT_InputComsol_RegionType" minOccurs="0"
            maxOccurs="unbounded"/>
        </xsd:sequence>
        <xsd:attribute name="mph" type="xsd:token" default="default">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
              File name of multiphysics .mph file corresponding to the grid
              in the .mphtxt file. If an additional multiphysics file is
              provided CFS++ reads the model.xml inside the .mph file, which
              is an ordinary zip file, and tries to aquire region names 
              from explicit selections of the first model. In the COMSOL GUI
              this maps to /filename.mph/Model 1/Definitions/... and in the
              model.xml this maps to
              /com.comsol.mph-vXX:Model/selection[1]/selections[1...n].
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of HDF5 data input type -->
  <!-- ******************************************************************** -->

  <!-- Data type for specification of input file format -->
  <xsd:complexType name="DT_InputHDF5">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
        Read the native CFS++ HDF5 file format. This format has the most complete
        set of supported features (mesh, data, restart info, etc.). HDF5 files
        can be generated using the ANSYS mkhdf5 extension, cplreader and cfstool.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="DT_InputBasic">
        <xsd:attribute name="generateRegionNodes" type="DT_CFSBool" default="no"/>
        <xsd:attribute name="readEntities" type="xsd:token" default=""/>
        <xsd:attribute name="linearizeEntities" type="xsd:token" default=""/>
        <xsd:attribute name="coordSysId" type="xsd:token" default="default"/>
        <xsd:attribute name="scaleFac" type="xsd:double" default="1.0"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of CGNS data input type -->
  <!-- ******************************************************************** -->

  <!-- Data type for specification of input file format -->
  <xsd:complexType name="DT_InputCGNS">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
        Read (C)FD (G)eneral (N)otation (S)ystem files (http://www.cgns.org).
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="DT_InputBasic">
        <xsd:attribute name="coordSysId" type="xsd:token" default="default"/>
        <xsd:attribute name="scaleFac" type="xsd:double" default="1.0"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of UNV  data input type -->
  <!-- ******************************************************************** -->

  <!-- Data type for specification of input file format -->
  <xsd:complexType name="DT_InputUNV">
    <xsd:annotation>
      <xsd:documentation xml:lang="de">
        Read Ideas universal files. These can e.g. be generated using
        Siemens NX PLM, GiD (File -> Export -> Using Template .bas -> UNV)
        or Gmsh.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="DT_InputBasic">
        <xsd:attribute name="mapXTo" type="DT_InputUNVCoordMap" default="x"/>
        <xsd:attribute name="mapYTo" type="DT_InputUNVCoordMap" default="y"/>
        <xsd:attribute name="mapZTo" type="DT_InputUNVCoordMap" default="z"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:simpleType name="DT_InputUNVCoordMap">
    <xsd:restriction base="xsd:token">
      <xsd:enumeration value="x"/>
      <xsd:enumeration value="y"/>
      <xsd:enumeration value="z"/>
      <xsd:enumeration value="zero"/>
    </xsd:restriction>
  </xsd:simpleType>

  <!-- ******************************************************************** -->
  <!--   Definition of ANSYS .cdb/.inp data input type -->
  <!-- ******************************************************************** -->

  <xsd:simpleType name="DT_InputCDBSurfElemsTypes">
    <xsd:restriction base="xsd:token">
      <xsd:enumeration value="nodeCmpToNamedElems"/>
      <xsd:enumeration value="nodeCmpToSurfRegions"/>
      <xsd:enumeration value="surfBCsToNamedElems"/>
    </xsd:restriction>
  </xsd:simpleType>

  <!-- Data type for specification of input file format -->
  <xsd:complexType name="DT_InputCDB">
    <xsd:annotation>
      <xsd:documentation xml:lang="de">
        The CFS++ .cdb/.inp reader can read mesh files generated with the
        ANSYS CDWRITE command (e.g. allsel\n cdwrite, db, 'file', 'cdb').
        The corresponding read command in ANSYS would therefore be CDREAD.
        ANSYS .cdb files can also be written using the Workbench interface.
        Also .inp files containing meshes may be read if they are not too
        general. The corresponding APDL command would be /INPUT.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="DT_InputBasic">
        <xsd:attribute name="strict" type="xsd:boolean" default="false">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
              If strict is true, no gaps in the node number list and the element
              number list are tolerated. Therefore, a nummrg may be in order before
              writing out the .cdb or .inp file.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="degenerate" type="xsd:boolean" default="false">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
              ANSYS usually writes wedges, pyras and tets as degenerated versions
              of hexas. If degenerate is false, CFS++ will convert the degenerated
              hexas to the proper type. If degenerate is true, CFS++ will just add
              the degenerated hexa connectivity to the grid.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="surfElemsMode" type="DT_InputCDBSurfElemsTypes"
          default="nodeCmpToSurfRegions">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
              ANSYS Workbench  Mechanical (Tools to Write Input  File) and
              Finite  Element Modeler  (Write APDL  Solver File)  write named  
              selections of surfaces  as node  components. Therefore,  the CDB  reader
              reconstructs  surface  elements from  node  components and adds them as
              surface regions by default (nodeCmpToSurfRegions). The surface elements
              can also be put into named element groups using nodeCmpToNamedElems.
              If  this attribute  is set to surfBCsToNamedElems, named elements can be
              generated by applying pressure surface BCs on the corresponding named
              selections. Please note, that also node components written from ANSYS
              Classic using CDWRITE are subject to this parameter!
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of Internal data input type -->
  <!-- ******************************************************************** -->

  <!-- Data type for specification of input file format -->
  <xsd:complexType name="DT_InputInternal">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
        Internal mesh is generated from input in xml-format.
      </xsd:documentation>
    </xsd:annotation>

    <xsd:complexContent>
      <xsd:extension base="DT_InputBasic"> </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of ENSIGHT (Gold) data input type -->
  <!-- ******************************************************************** -->

  <!-- Data type for specification of input file format -->
  <xsd:complexType name="DT_InputEnsight">
    <xsd:complexContent>
      <xsd:extension base="DT_InputBasic">
        <xsd:sequence>
          <xsd:element name="variableList" maxOccurs="1" minOccurs="0">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="variable" minOccurs="0" maxOccurs="unbounded">
                  <xsd:complexType>
                    <xsd:attribute name="CFSVarName" use="required" type="xsd:token"/>
                    <!--xsd:annotation >
                        <xsd:documentation xml:lang="en">
                         CFS++ compliant variable name. May be one of fluidMechPressure | fluidMechVelocity |
                         fluidMechPressure_deriv2
                        </xsd:documentation>
                      </xsd:annotation-->
                    <xsd:attribute name="EnsightVarName" use="required" type="xsd:token"/>
                    <!--xsd:annotation >
                        <xsd:documentation xml:lang="en">
                          Name of variable as given in case file
                        </xsd:documentation>
                      </xsd:annotation-->
                    <!--xsd:attribute name="multByCellVolume" use="optional"  type="xsd:boolean" default="false"/-->
                    <!--xsd:annotation >
                        <xsd:documentation xml:lang="en">
                          If this is true, the value at node/cellCenter is multiplied by the cell volume
                          during read. 
                        </xsd:documentation>
                      </xsd:annotation-->
                    <!--xsd:attribute name="type">
                      <xsd:simpleType>
                        <xsd:restriction>
                          <xsd:enumeration value="vector"/>
                          <xsd:enumeration value="scalar"/>                          
                        </xsd:restriction>                        
                      </xsd:simpleType>
                    </xsd:attribute-->
                    <xsd:attribute name="static" type="DT_CFSBool" default="no"/>
                    <xsd:attribute name="dof" use="optional" type="xsd:token">
                      <xsd:annotation>
                        <xsd:documentation xml:lang="en">
                          In case of vectors (e.g. velocity) which are stored component wise as scalar results we can give the 
                          target dof for CFS here.
                        </xsd:documentation>
                      </xsd:annotation>
                    </xsd:attribute>
                  </xsd:complexType>
                </xsd:element>
              </xsd:sequence>
            </xsd:complexType>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="readEntities" type="xsd:token" default=""/>
        <xsd:attribute name="linearizeEntities" type="xsd:token" default=""/>
        <xsd:attribute name="coordSysId" type="xsd:token" default="default"/>
        <xsd:attribute name="scaleFac" type="xsd:double" default="1.0"/>
        <xsd:attribute name="readFVMesh" type="DT_CFSBool" default="no"/>
        <xsd:attribute name="fixFVPyramids" type="DT_CFSBool" default="yes"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of the python mesh input type -->
  <!-- ******************************************************************** -->

  <xsd:complexType name="DT_InputPython">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
         Run embedded python interpreter to get mesh data from a python script.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="DT_InputBasic">
       <xsd:sequence>
         <xsd:element name="option" minOccurs="0" maxOccurs="unbounded">
           <xsd:complexType>
             <xsd:attribute name="key" type="xsd:string" use="required" />
             <xsd:attribute name="value" type="xsd:string" use="required" />
           </xsd:complexType>
         </xsd:element>
        </xsd:sequence>
        <!-- fileName is from DT_InputBasic -->
        <!-- optional root for file with cfs:share:python a special key to be resolved via schema path -->
        <xsd:attribute name="path" type="xsd:string" use="optional" default="" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of scattered data input type -->
  <!-- ******************************************************************** -->

  <xsd:group name="ScatteredDataGroup">
    <xsd:choice>
      <xsd:element name="csv" type="DT_ScatteredDataCSV"/>
      <xsd:element name="csvt" type="DT_ScatteredDataCSVT"/>
      <xsd:element name="ccm" type="DT_ScatteredDataCCM"/>
    </xsd:choice>
  </xsd:group>

  <!-- Data type for specification of input file format -->
  <xsd:complexType name="DT_InputScatteredData">
    <xsd:annotation>
      <xsd:documentation xml:lang="de">
        Scattered data is defined with respect to point clouds. No grid
        is associated with scattered data.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:group ref="ScatteredDataGroup" minOccurs="1" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of basic scattered input type -->
  <!-- ******************************************************************** -->
  <xsd:complexType name="DT_ScatteredDataBasic">
    <xsd:attribute name="fileName" use="required" type="xsd:token">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          Full path of file containing the scattered data.
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="id" use="required" type="xsd:token">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          Unique id for input reader which reads from the given file.
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of basic quantity type for scattered data -->
  <!-- ******************************************************************** -->
  <xsd:complexType name="DT_ScatteredQuantityBasic" abstract="true">
    <xsd:sequence>
      <xsd:element name="bbox" maxOccurs="1" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation xml:lang="en">
            Only data points contained in this bounding box are considered
            for the database inside the CoefFunctionScatteredData.
          </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
          <xsd:attribute name="xmin" type="xsd:double" use="required"/>
          <xsd:attribute name="ymin" type="xsd:double" use="required"/>
          <xsd:attribute name="zmin" type="xsd:double" use="required"/>
          <xsd:attribute name="xmax" type="xsd:double" use="required"/>
          <xsd:attribute name="ymax" type="xsd:double" use="required"/>
          <xsd:attribute name="zmax" type="xsd:double" use="required"/>
        </xsd:complexType>
      </xsd:element>
      <xsd:element name="dump" maxOccurs="1" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation xml:lang="en">
            Dump point cloud data contained in the CoefFunctionScatteredData
            to a file.
          </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
          <xsd:attribute name="fileName" type="xsd:token" use="required"/>
          <xsd:attribute name="format" type="xsd:token" use="optional" default="csv"/>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:token" use="required">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          Name of this quantity
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="id" use="required" type="xsd:token">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          Id for this scattered data quantity.
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="factor" type="xsd:double" default="1.0">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          A scaling factor for all components of the values.
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="searchRadius" type="xsd:double" default="1.0">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          Search raduis for the neighbors.
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="interpolAlgo" use="optional" default="shepard">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          Interpolation algorithm for scattered data points. May be one of shepard, nearest-neighbor.
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="numNeighbors" use="optional" type="xsd:unsignedInt" default="20">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          Number of scattered data points to include in interpolation.
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="p" use="optional" type="xsd:double" default="2.0">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          Exponent for calculation of weights.
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="knnLib" use="optional" default="cgal">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          Library for k-nearest-neighbor search. May be one of cgal or flann.
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of scattered quantity for .csv files -->
  <!-- ******************************************************************** -->
  <xsd:complexType name="DT_ScatteredQuantityCSV">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
        The columns of the single degrees of freedom (dofs) for the values
        can be specified component-wise.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="DT_ScatteredQuantityBasic">
        <xsd:sequence>
          <xsd:element name="comp" minOccurs="1" maxOccurs="unbounded">
            <xsd:complexType>
              <xsd:attribute name="dof" type="xsd:token" use="required"/>
              <xsd:attribute name="col" type="xsd:nonNegativeInteger" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of input tag for .csv files -->
  <!-- ******************************************************************** -->
  <xsd:complexType name="DT_ScatteredDataCSV">
    <xsd:complexContent>
      <xsd:extension base="DT_ScatteredDataBasic">
        <xsd:sequence>
          <xsd:element name="coordinates" minOccurs="1" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation xml:lang="en">
                The columns of the single degrees of freedom (dofs) for the point
                coordinates can be specified component-wise.
              </xsd:documentation>
            </xsd:annotation>
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="comp" minOccurs="1" maxOccurs="unbounded">
                  <xsd:complexType>
                    <xsd:attribute name="dof" type="xsd:token" use="required"/>
                    <xsd:attribute name="col" type="xsd:nonNegativeInteger" use="required"/>
                  </xsd:complexType>
                </xsd:element>
              </xsd:sequence>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="quantity" minOccurs="1" maxOccurs="1" type="DT_ScatteredQuantityCSV"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of scattered quantity for .csvt files -->
  <!-- ******************************************************************** -->
  <xsd:complexType name="DT_ScatteredQuantityCSVT">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
        The columns of the single degrees of freedom (dofs) for the values
        can be specified component-wise.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="DT_ScatteredQuantityBasic">
        <xsd:sequence>
          <xsd:element name="comp" minOccurs="1" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation xml:lang="en">
                For complex numbers each entry in the data file must have the form
                (a+ib).
              </xsd:documentation>
            </xsd:annotation>
            <xsd:complexType>
              <xsd:attribute name="dof" type="xsd:token" use="optional"/>
              <xsd:attribute name="col" type="xsd:nonNegativeInteger" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of input tag for .csvt files -->
  <!-- ******************************************************************** -->
  <xsd:complexType name="DT_ScatteredDataCSVT">
    <xsd:complexContent>
      <xsd:extension base="DT_ScatteredDataBasic">
        <xsd:sequence>
          <xsd:element name="stepValues" minOccurs="1" maxOccurs="1">
            <xsd:complexType>
              <xsd:attribute name="col" type="xsd:nonNegativeInteger" use="required"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="stepFiles" minOccurs="1" maxOccurs="1">
            <xsd:complexType>
              <xsd:attribute name="col" type="xsd:nonNegativeInteger" use="required"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="coordinates" minOccurs="1" maxOccurs="1">
            <xsd:annotation>
              <xsd:documentation xml:lang="en">
                Each point of the scattered data points is described bz its 
                coordinates (x,z,y), they are stored in the file name given
                in the description.
              </xsd:documentation>
            </xsd:annotation>
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="comp" minOccurs="1" maxOccurs="unbounded">
                  <xsd:complexType>
                    <xsd:attribute name="dof" type="xsd:token" use="required"/>
                    <xsd:attribute name="col" type="xsd:nonNegativeInteger" use="required"/>
                  </xsd:complexType>
                </xsd:element>
              </xsd:sequence>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="quantity" minOccurs="1" maxOccurs="1" type="DT_ScatteredQuantityCSVT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of scattered quantity for .ccm files -->
  <!-- ******************************************************************** -->
  <xsd:complexType name="DT_ScatteredQuantityCCM">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
        The field short names of the single degrees of freedom (dofs) for the values
        can be specified component-wise. The default values for the dofs x, y, z are SU, SV and SW.
        The short names of the fields can be found in the .ccm files under e.g.
        /FieldSets/FieldSet-1/Phase-1/Fields/Velocity_0/ShortName. The cgnsview executable can be used
        to open the ADF tree inside the .ccm file.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="DT_ScatteredQuantityBasic">
        <xsd:sequence>
          <xsd:element name="comp" minOccurs="1" maxOccurs="unbounded">
            <xsd:complexType>
              <xsd:attribute name="dof" type="xsd:token" use="required"/>
              <xsd:attribute name="shortName" type="xsd:token" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of input tag for STAR-CCM+ .ccm files -->
  <!-- ******************************************************************** -->
  <xsd:complexType name="DT_ScatteredDataCCM">
    <xsd:complexContent>
      <xsd:extension base="DT_ScatteredDataBasic">
        <xsd:sequence>
          <xsd:element name="quantity" minOccurs="1" maxOccurs="1" type="DT_ScatteredQuantityCCM">
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="dump" type="xsd:boolean" use="optional" default="false">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
              Dump point cloud data to a CSV file. 
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="cellCenters" type="xsd:boolean" use="optional" default="true">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
              Read data from cell centers. 
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="faceCenters" type="xsd:boolean" use="optional" default="true">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
              Read data from face centers. 
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:group name="OutputGroup">
    <xsd:choice>
      <xsd:element name="gmsh" type="DT_OutputGMsh" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="gmshParsed" type="DT_OutputGMshParsed" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="unv" type="DT_OutputUNV" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="gid" type="DT_OutputGiD" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="hdf5" type="DT_OutputHDF5" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="rst" type="DT_OutputRST" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="cgns" type="DT_OutputCGNS" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="text" type="DT_OutputText" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="csv" type="DT_OutputCSV" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="info" type="DT_OutputInfo" minOccurs="0" maxOccurs="1"/>
      <xsd:element name="streaming" type="DT_OutputStreaming" minOccurs="0" maxOccurs="1"/>
    </xsd:choice>
  </xsd:group>

  <!-- Data type for specification of output file format -->
  <xsd:complexType name="DT_OutputList">
    <xsd:sequence>
      <xsd:group ref="OutputGroup" minOccurs="1" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of data type for GMsh output -->
  <!-- ******************************************************************** -->
  <xsd:complexType name="DT_OutputGMsh">
    <xsd:attribute name="endianness" type="DT_CFSEndianness" default="native"/>
    <xsd:attribute name="binaryFormat" type="DT_CFSBool" default="yes"/>
    <xsd:attribute name="id" type="xsd:token" default="gmsh"/>
    <xsd:attribute name="gridId" type="xsd:token" default="default"/>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of data type for OutputGMshParsed output High order FEM -->
  <!-- ******************************************************************** -->
  <xsd:complexType name="DT_OutputGMshParsed">
    <xsd:attribute name="id" type="xsd:token" default="gmshParsed"/>
    <xsd:attribute name="writeMode" type="xsd:token" default="region"/>
    <xsd:attribute name="gridId" type="xsd:token" default="default"/>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of data type for UNV output -->
  <!-- ******************************************************************** -->
  <xsd:complexType name="DT_OutputUNV">
    <xsd:attribute name="id" type="xsd:token" default="unv"/>
    <xsd:attribute name="gridId" type="xsd:token" default="default"/>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition writing history data to InfoNode output -->
  <!-- ******************************************************************** -->
  <xsd:complexType name="DT_OutputInfo">
    <xsd:attribute name="id" type="xsd:token" default="info"/>
    <xsd:attribute name="gridId" type="xsd:token" default="default"/>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition writing results to a streaming receiver -->
  <!-- ******************************************************************** -->
  <xsd:complexType name="DT_OutputStreaming">
    <xsd:attribute name="id" type="xsd:token" default="streaming"/>
    <!-- e.g. "127.0.0.1" or "localhost". Mandatory for protocol = http -->
    <xsd:attribute name="host" type="xsd:token" use="optional"/>
    <!-- e.g. "80" -->
    <xsd:attribute name="port" type="xsd:nonNegativeInteger" use="optional" default="80"/>
    <!-- e.g. "/iTop/cfspost.php" or the file -->
    <!-- for streamviz service either use "/" or "/cfs_receive" -->
    <xsd:attribute name="path" type="xsd:token" use="optional" default="/"/>
    <!-- the protocol. http is what streaming is meant for, file for iTop compression test. A fast
    XML output -->
    <xsd:attribute name="protocol" default="http">
      <xsd:simpleType>
        <xsd:restriction base="xsd:token">
          <xsd:enumeration value="http"/>
          <xsd:enumeration value="file"/>
        </xsd:restriction>
      </xsd:simpleType>
    </xsd:attribute>
    <!-- shall also the grid be transmitted -->
    <xsd:attribute name="sendMesh" type="xsd:boolean" use="optional" default="false" />
    <!-- if not silent prints on which port a connectiont is attempted to -->
    <xsd:attribute name="silent" type="xsd:boolean" use="optional"/>
    <xsd:attribute name="gridId" type="xsd:token" default="default"/>    
  </xsd:complexType>


  <!-- ******************************************************************** -->
  <!--   Definition of data type for GiD output -->
  <!-- ******************************************************************** -->
  <xsd:complexType name="DT_OutputGiD">
    <xsd:attribute name="binaryFormat" type="DT_CFSBool" default="yes"/>
    <xsd:attribute name="groupEigenFreqs" type="DT_CFSBool" default="yes"/>
    <xsd:attribute name="id" type="xsd:token" default="gid"/>
    <xsd:attribute name="directory" type="xsd:string" default="results_gid"/>
    <xsd:attribute name="gridId" type="xsd:token" default="default"/>
    <xsd:attribute name="mergeSequenceSteps" type="DT_CFSBool" default="yes"/>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of data type for HDF5 output -->
  <!-- ******************************************************************** -->
  <xsd:complexType name="DT_OutputHDF5">
    <xsd:attribute name="externalFiles" type="DT_CFSBool" default="no"/>
    <xsd:attribute name="maxChunkSize" type="xsd:nonNegativeInteger" default="128"/>
    <xsd:attribute name="compressionLevel" default="6">
      <xsd:simpleType>
        <xsd:restriction base="xsd:nonNegativeInteger">
          <xsd:maxInclusive value="9"/>
        </xsd:restriction>
      </xsd:simpleType>
    </xsd:attribute>
    <xsd:attribute name="directory" type="xsd:string" default="results_hdf5"/>
    <xsd:attribute name="extension" type="xsd:string" default="cfs"/>
    <xsd:attribute name="id" type="xsd:token" default="hdf5"/>
    <xsd:attribute name="gridId" type="xsd:token" default="default"/>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of data type for ANSYS RST output -->
  <!-- ******************************************************************** -->
  <xsd:complexType name="DT_OutputRST">
    <xsd:attribute name="ansysRevision" default="11.0">
      <xsd:simpleType>
        <xsd:restriction base="xsd:float">
          <xsd:minInclusive value="10.0"/>
          <xsd:maxInclusive value="14.0"/>
        </xsd:restriction>
      </xsd:simpleType>
    </xsd:attribute>
    <xsd:attribute name="id" type="xsd:token" default="rst"/>
    <xsd:attribute name="gridId" type="xsd:token" default="default"/>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of data type for CGNS output -->
  <!-- ******************************************************************** -->
  <xsd:complexType name="DT_OutputCGNS">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
        Write (C)FD (G)eneral (N)otation (S)ystem files (http://www.cgns.org).
      </xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="directory" type="xsd:string" default="results_cgns"/>
    <xsd:attribute name="id" type="xsd:token" default="cgns"/>
    <xsd:attribute name="gridId" type="xsd:token" default="default"/>
    <xsd:attribute name="mll" type="DT_OutputCGNSMidLevelLibraries" default="default">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          Mid level library used to write CGNS SIDS. May be one of hdf5, adf,
          adf2 or default. By default adf is used in order to support also older
          post-processors. This behavior may however be changed by setting the 
          environment variable CGNS_FILETYPE to one of hdf5, adf or adf2. CFS++
          is linked to CGNS 3.1. Therefore hdf5 will be used if CGNS_FILETYPE is
          not defined and 'mll' is set to 'default'.
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="writeQuadElems" type="xsd:boolean" default="false">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          Even if the CGNS library properly defines complete and incomplete
          quadratic element types, most post-processors (VisIt, ParaView with
          VisItBridge, EnSight) have problems handling them. Therefore, we just
          write linear element types by default.
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="complexFormat" type="DT_ComplexFormat" default="realImag">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          Format for complex-valued results.
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="separateFiles" type="xsd:boolean" default="true">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          It has been found, that some post-processors for CGNS (VisIt &lt;= 2.7,
          EnSight &lt;= 10.0) have problems handling nodal and element results 
          defined under the same base node. ParaView (&lt;= 4.1) may go to 100% CPU 
          load and even crash! Even if the different result types are defined with
          respect to different base nodes in the same .cgns file, which would be okay
          for ParaView, VisIt and EnSight have problems handling this situation.
          Therefore, the default is to write node and element results to different
          files.
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>

  <xsd:simpleType name="DT_OutputCGNSMidLevelLibraries">
    <xsd:restriction base="xsd:token">
      <xsd:enumeration value="adf"/>
      <xsd:enumeration value="adf2"/>
      <xsd:enumeration value="hdf5"/>
      <xsd:enumeration value="default"/>
    </xsd:restriction>
  </xsd:simpleType>

  <!-- ******************************************************************** -->
  <!--   Definition of data type for text output -->
  <!-- ******************************************************************** -->
  <xsd:complexType name="DT_OutputText">
    <xsd:attribute name="commentChar" type="DT_Character" default="#"/>
    <xsd:attribute name="coordSysId" type="xsd:token" default="default"/>
    <xsd:attribute name="fileCollect" default="entity">
      <xsd:simpleType>
        <xsd:restriction base="xsd:token">
          <xsd:enumeration value="entity"/>
          <xsd:enumeration value="timeFreq"/>
          <xsd:enumeration value="altogether"/>
        </xsd:restriction>
      </xsd:simpleType>
    </xsd:attribute>
    <xsd:attribute name="entityNumbering" default="global">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          Determines the naming scheme for text files of nodes / element
          results: In case of 'global' numbering, the text files contain the
          global node / element number. In case of 'consecutive', the text
          files of a node / element list get enumerated from 1 on based on a 
          consecutive numbering.
        </xsd:documentation>
      </xsd:annotation>
      <xsd:simpleType>
        <xsd:restriction base="xsd:token">
          <xsd:enumeration value="global"/>
          <xsd:enumeration value="consecutive"/>
        </xsd:restriction>
      </xsd:simpleType>
    </xsd:attribute>
    <xsd:attribute name="id" type="xsd:token" default="txt"/>
    <xsd:attribute name="gridId" type="xsd:token" default="default"/>
  </xsd:complexType>

  <!-- ******************************************************************** -->
  <!--   Definition of data type for CSV output -->
  <!-- ******************************************************************** -->
  <xsd:complexType name="DT_OutputCSV">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
        Format history output file as comma separated values which can be read directly into ParaView.
        
        The Matlab/Octave code to read such files is: matrix = csvread('vel-line.csv',1,0);
        
        For Python refer to http://matplotlib.org/api/mlab_api.html#matplotlib.mlab.csv2rec or
        http://docs.python.org/2/library/csv.html
      </xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="delimiter" type="DT_Character" default=",">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          The delimiter character for the CSV file can be defined here. By default a comma is used.
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="coordSysId" type="xsd:token" default="default"/>
    <xsd:attribute name="fileCollect" default="entity">
      <xsd:simpleType>
        <xsd:restriction base="xsd:token">
          <xsd:enumeration value="entity"/>
          <xsd:enumeration value="timeFreq"/>
          <xsd:enumeration value="altogether"/>
        </xsd:restriction>
      </xsd:simpleType>
    </xsd:attribute>
    <xsd:attribute name="entityNumbering" default="global">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          Determines the naming scheme for text files of nodes / element
          results: In case of 'global' numbering, the text files contain the
          global node / element number. In case of 'consecutive', the text
          files of a node / element list get enumerated from 1 on based on a 
          consecutive numbering.
        </xsd:documentation>
      </xsd:annotation>
      <xsd:simpleType>
        <xsd:restriction base="xsd:token">
          <xsd:enumeration value="global"/>
          <xsd:enumeration value="consecutive"/>
        </xsd:restriction>
      </xsd:simpleType>
    </xsd:attribute>
    <xsd:attribute name="id" type="xsd:token" default="csv"/>
    <xsd:attribute name="gridId" type="xsd:token" default="default"/>
  </xsd:complexType>

  <!-- Data type for name of file containing material data -->
  <xsd:complexType name="DT_MatFile">
    <xsd:attribute name="file" type="xsd:string" use="optional" default="mat.xml"/>
    <xsd:attribute name="format" use="optional" default="xml">
      <xsd:simpleType>
        <xsd:restriction base="xsd:token">
          <xsd:enumeration value="xml"/>
        </xsd:restriction>
      </xsd:simpleType>
    </xsd:attribute>
  </xsd:complexType>




</xsd:schema>
